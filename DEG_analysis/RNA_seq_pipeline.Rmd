---
title: "RNASeq Pipeline"
author: "Mari Johnson"
date: '2022-08-29'
output: html_document
---

```{r Rmd setup}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, error = TRUE)
knitr::opts_knit$set(root.dir = '/home/mari/RNA/Daniel') #Permanently sets wd for Rmd
```
### Aims:

1) To pre-process RNAseq data for typhoid challenge/vaccination studies
2) To run differential gene expression analysis at a global and gene level scale

### Overview of chapters

1) Pre-processing
- Read and structure count data
- Remove lowly expressed genes
- Transform and normalise data
- Limma Voom

2) Differential gene expression analysis
- Create design matrix
- Fit linear model for comparisons of interest
- Examine differentially expressed genes
- Visualise comparisons with volcano plots

3) Spline gene modelling 
- Re-organise normalised RNAseq data from voom object
- Fit splines model to gene expression values over time course
- Visualise changes in gene expression using fitted splines/box plots
- Test for statistical significance


Source Materials:
- https://ucdavis-bioinformatics-training.github.io/2018-June-RNA-Seq-Workshop/thursday/DE.html
- https://www.bioconductor.org/packages/devel/workflows/vignettes/RNAseq123/inst/doc/limmaWorkflow.html
- https://www.youtube.com/watch?v=z36fu178jIQ&ab_channel=LiquidBrainBioinformatics



## 1) Pre-processing

### Set up and tidy data

```{r Set Directories, warning=FALSE, message=FALSE}
setwd("/home/mari/RNA/Daniel") #where data is saved
plot_dir <- c("~/GWAS_22/new_gwas/Plots/DEG/pre-process/") #where to save output plots

#load packages #
library(dplyr)
library(data.table)
library(ggplot2)
library(ggrepel) 
library(tidyr)
library(tidylog)
library(limma)
library(stringi)
library(janitor)
library(stringr)
library(splines)
library(edgeR)
library(BiocManager)
library(DESeq2)
library(Glimma)
library(RColorBrewer)
```

```{r functions}
#Just contrast matrix function ####
make_contrasts <- function (group, control, delim="_vs_", des_mat){
  #/ define groups and baseline to make contrasts
  
  suppressMessages(require(limma))
  
  #Checks
  if(is.null(group)) stop("Error: group arg is missing")
  
  #/ ensure unique group levels
  group <- sort(unique(as.character(group)))
  
  #Write limma code by pasting groups
  #/ if control var is present, compare all groups to control
  #/  else make all comparisons using combn function
  if (!missing(control)){
    combo <- paste0(group,"-",  control)
  } else{
    combo <- combn(group, 2, FUN = function(x){paste0(x[1], "-", x[2])})
  }
  
  #/ make contrasts
  if (!missing(des_mat)){
  contrasts<- limma::makeContrasts(contrasts=combo, levels=colnames(des_mat))
  }else{
    contrasts<- limma::makeContrasts(contrasts=combo, levels=group)
    message("No Design Matrix provided, using only defined contrasts for matrix")
  }
  colnames(contrasts) <- gsub("-", delim, colnames(contrasts))
  #Todo: levels need to be design matrix, poss modify to have group or design option later
  #Only do lmfit step if design and fit are supplied
  
  return(contrasts)
}


#Combo with ebayes #####
contrast_2_lm <- function(group, control, delim="_vs_", des_mat, efit, topTab="TRUE"){
  #Define groups and baseline to make contrasts
  #Input design and previous model fit model for it to work
  #Toptab gives option to output results
  
  #/ Checks
  suppressMessages(require(limma))
  if(is.null(group)) stop("Error: group arg is missing")
  
  #/ Ensure unique group levels
  group <- sort(unique(as.character(group)))
  
  #/ Define contrasts 
  if (!missing(control)){ #compare to control
    combo <- paste0(group,"-",  control)
  } else{ #make all pairwise comparisons
    combo <- combn(group, 2, FUN = function(x){paste0(x[1], "-", x[2])}) 
  }
  
  #/ Make contrast matrix
  if (!missing(des_mat)){
    contrasts<- limma::makeContrasts(contrasts=combo, levels=colnames(design))
  }else{ #No design + no efit
    contrasts<- limma::makeContrasts(contrasts=combo, levels=group)
    message("No Design Matrix provided, using only defined contrasts for matrix")
  } 
  colnames(contrasts) <- gsub("-", delim, colnames(contrasts))
  
 
  #/ Model fit and deg results
  if (!missing(efit) & !missing(des_mat) & topTab == "TRUE"){ #Requires efit and dmat args
    fit2 <- contrasts.fit(efit, contrasts)
    fit2 <- eBayes(fit2)
    message("Performing ebayes fit of linear model")
    top_results <- list() #TopTable Results
    for (i in colnames(contrasts)){
      top_results[[i]] <- topTable(fit2, coef = i, number = Inf)
      limma_list <- list(contrasts = contrasts, fit2 = fit2, top_results = top_results)
    }
    message("Contrast matrix (contrasts), ebayes (fit2), top DEGs (top_results) saved in list\n
          Subset list with either $ or [[]] for results")
  } else if (!missing(efit) & !missing(des_mat) & topTab != "TRUE"){ #Without toptable option
    fit2 <- contrasts.fit(efit, contrasts)
    fit2 <- eBayes(fit2)
    message("Performing ebayes fit of linear model")
    limma_list <- list(contrasts = contrasts, fit2 = fit2)
  } else if (missing(efit) | missing(des_mat)) {
    limma_list <- list(contrasts)
    warning("No linear model or design matrix supplied, returning contrast matrix only")
  }
  return(limma_list)
}

#Volcano plot function ####

plot_vol <- function(deg, p = 0.05, FC = 0,
                     lab_type= "top", genes, top = 20,
                     gene_col = "gene_name", #colname with gene_IDs
                     title="", alpha = 0.98,
                     colours = c("#a50000","#800000","#ef5a3a","orange","yellow")) {

  
#/ Checks
if (missing(deg)){
  stop("Error: deg arg is missing. Please provide a toptable data frame")} 
#if (!missing(genes) & !is.character(genes)){
  #stop("Error: label is not a character vector")}
if (!missing(lab_type) & lab_type != c('top') & missing(genes)) {
  stop("Error: label requires character vector with selected genes")}

  #/ 1) Define sig values
  log_p <- -log10(p)
  #Adj p values #need to convert adjusted p-val to unadjusted for plot yscale
  values <- seq(0.050,0.051, by=0.00001)
  deg$adj.P.Val <- round(deg$adj.P.Val, 5) #This is such a janky way I apologise
  adj.p <- deg[(deg$adj.P.Val %in% (values)),c("P.Value")] 
  adj.p <-  min(adj.p)
  log_adj <- -log10(adj.p)
  
  ##/Set up reg table 2)
 
  deg <- deg %>%
    mutate(reg =
             case_when(
               deg$logFC >= FC & deg$adj.P.Val <= p ~ "Sig Adj. P <0.05",
               deg$logFC <= FC & deg$adj.P.Val <= p ~ "Sig Adj. P <0.05",
               deg$logFC >= FC & deg$P.Value <= p ~ "Sig P <0.05",
               deg$logFC <= FC & deg$P.Value <= p ~ "Sig P <0.05",
               abs(deg$logFC) <= FC & deg$adj.P.Val >= p ~ "No Change",
               abs(deg$logFC) <= FC & deg$adj.P.Val <= p ~ "No Change",
               abs(deg$logFC) > FC & deg$adj.P.Val >p ~ "No Change")) %>%
    mutate(reg =
             factor(reg, levels =
                      c("Sig Adj. P <0.05", "Sig P <0.05", "No Change")))
  
  #Define labels 3)
  
  if (is.null(lab_type)){#No entry for lab list, currently there's no default arg
    gene_label <- c("")
    lab_data <- NULL #Empty dataframe, need to work out how not to error
    warning("No genes highlighted")
  } else if(lab_type == "sig"){
      gene_label <- genes
      lab_data <- deg[(deg$reg == "Sig P <0.05" |deg$reg == "Sig Adj. P <0.05" )
                    & (deg$gene_col %in% genes),]
  } else if (lab_type == "ns"){
        gene_label <- genes
        lab_data <- deg[(deg$gene_col %in% genes),]}
    else if (lab_type == "top"){
          lab_data <- slice_min(deg,adj.P.Val,n=top)
          gene_label <- lab_data$gene_col
  }


#Plot Volcano 4)
vol <-
  deg %>% ggplot(aes(x=logFC,y=-log10(P.Value),label=gene_name))+
  geom_point(aes(color = P.Value, alpha=alpha))+
  labs(title = title) +
  theme_minimal() +theme(legend.position = "none") +
  geom_hline(yintercept = log_p, linetype = 2.5, alpha =0.7) +
  geom_hline(yintercept =log_adj, linetype = 2.5, alpha =0.7)+
  geom_label_repel(data=lab_data,
                   size=3.5,direction="both",nudge_y =1.6,nudge_x =0.1,
                   angle= 70,vjust= 0,segment.size= 0.5,
                   segment.color="#331002",fill="#f7f7f5")+
  scale_color_gradientn(colours = colours,
                        values=c(0,adj.p,p,1))
return(vol)
} 

```

```{r Set up Data, include = FALSE}
load("/home/mari/RNA/Daniel/Filter2_VAST_STAR_HTSeq_gene_meta_autosomes_mismatch_corrected_demo_minus_rRNA_globins_autosomes_2021-04-27.R")
data <- VAST_autosomes #RNAseq data set
#rm(VAST_autosomes)

#Clean names using janitor package
str(data$samples)
data$meta_data <- clean_names(data$meta_data)
#Rename variables
names(data$meta_data)[names(data$meta_data) == "days_since_challenge"] <- "time"
#Remove NA participant IDs (these are in y - transfer over)
#colnames(data$meta_data)<-gsub("_x","",colnames(data$meta_data))
colnames(data$meta_data) <- stri_replace_all_regex(colnames(data$meta_data),
                                  pattern=c('_x', 'x_',
                                            '_e2_c3', 'e3_c3', 'e5_c5'),
                                  replacement=c(''),
                                  vectorize=FALSE)

#Remove control samples - as these have diff time points, causes a later issue with time and vaccine being linearly dependent, analyse seperately for now
table(data$meta_data$study_arm)
samples <- data$samples[(data$meta_data$study_arm != "CTRL"),]
meta_data <- data$meta_data[(data$meta_data$study_arm != "CTRL"),]
samples <- cbind(samples,meta_data)
data$gene[(data$meta_data$study_arm != "CTRL"),]
genes <- data$genes[(data$meta_data$study_arm != "CTRL"),]
#filter col names in row names of metadata #row, col
counts <- data$counts[rownames(data$counts) %in% rownames(genes),
                      colnames(data$counts) %in% meta_data$row_names]
#filter rows (genes in counts, by the colnames (genes) in genes)
#reform s3 DGElist object
data <- DGEList(counts=counts,
                genes = genes,
                samples = samples)

```
### Filter and normalise genes

Low expressed genes will be unreliable/not worth testing so remove these low count genes
Additionally need to normalise data to account for library size/gene counts

*Calcualte log counts/per million*
```{r Calculate log counts/per million}
#Convert counts to log to minimise the effect of small values and negatives
cpm <- cpm(data)
lcpm <- cpm(data, log=TRUE) #Used for exploratory plots/checks
L <- mean(data$samples$lib.size) * 1e-6 #average library size
M <- median(data$samples$lib.size) * 1e-6
c(L, M)
```
*Remove Lowly expressed genes*
```{r Remove Lowly expressed genes, warning=FALSE}
#Remove genes with no counts
table(rowSums(data$counts==0)==427)
#Filter low values using edgeR algorithm
keep.exprs <- filterByExpr(data)
# Warning - all samples appear to belong to the same group
data2 <- data[keep.exprs, keep.lib.sizes=FALSE] #subset og data
dim(data2) #12969 genes across 521 participants
```
*Visualise the frequency of counts across study before and after filtering*
```{r Visualise raw and filtered count data, warning=FALSE}
lcpm.cutoff <- log2(10/M + 2/L)
nsamples <- ncol(data) #521/514
col <- brewer.pal(nsamples, "Paired")

#Plot Raw Log-cpm against density
pdf(paste(plot_dir,"filter.pdf",sep =""))
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.26), las=2, main="", xlab="")
title(main="A. Raw data", xlab="Log-cpm")
abline(v=lcpm.cutoff, lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x, den$y, col=col[i], lwd=2)
}
#Plot filtered count data
lcpm <- cpm(data2, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.26), las=2, main="", xlab="")
title(main="B. Filtered data", xlab="Log-cpm")
abline(v=lcpm.cutoff, lty=3)
for (i in 2:nsamples){
  den <- density(lcpm[,i])
  lines(den$x, den$y, col=col[i], lwd=2)
}

#Save filtered data as main DF
data <- data2
rm(data2)

#Normalise data ###
data <- calcNormFactors(data, method = "TMM")#Normalises count data via TMM scale

```
### MDS plots 

- Visually examine the factors to include in you linear modelling
- These could include technical factors such as sequencing lane/batch and also experimental factors such as time points/diagnosis
- Ideally you would want to see differences in time points where we expect to see DEG's, and less variation between technical factors
- If there is no clustering then that factor is not necessary for the lm
- You can also test for two factors together using interaction terms, e.g\
  `group = interaction(data$meta_data$sequence_pool,data$meta_data$TimePoint)`

```{r MDS plot}
#Sequencing lane check
group = as.factor(data$samples$sequence_pool)
#Set up group to plot/colours
lcpm<-cpm(data,log=TRUE)
col.group <-group
levels(col.group) <-brewer.pal(nlevels(col.group),"Accent")
col.group<-as.character(col.group)

#Plot MDS 
pdf(paste(plot_dir,"sequence_pool2.pdf",sep =""))
plotMDS(lcpm,labels=group,col=col.group)
title(main= "Sequencing Pool")
dev.off()
```
#### Batch correction Notes:

From the MDS plot we can see a significant batch effect in sequencing pool\
You can account for batch corrections using limma (this might be useful for raw data in splines\ model later) e.g `limma::removeBatchEffect(cpm, data$meta_data$sequence_pool)`\
Remove batch effect from raw counts and then reconvert to lcpm to get rid of negative value, which disturb the model. Re-normalise batch corrected values?\
But for DEG analysis just include sequencing_pool as a co-variate in the model\

```{r Time point MDS, message=FALSE}
#Time point MDS
group = as.factor(data$samples$time_point3)
col.group<-group
#Set colours
palette_Dark2 <- colorRampPalette(brewer.pal(8, "Set2"))
levels(col.group)<-palette_Dark2(length(unique(data$samples$time_point3)))
col.group<-as.character(col.group)
#Plot MDS
pdf(paste(plot_dir,"time_mds.pdf",sep =""))
#starts writing a PDF to file
plotMDS(lcpm,labels=group,col=col.group)
title(main= "Time Point") #Some clustering around TD already :)
dev.off()
```
```{r Vaccine MDS, message=FALSE}
#Time point MDS
group = as.factor(data$samples$study_arm)
col.group<-group
#Set colours
palette_Dark2 <- colorRampPalette(brewer.pal(8, "Set2"))
levels(col.group)<-palette_Dark2(length(unique(data$samples$time_point3)))
col.group<-as.character(col.group)
#Plot MDS
pdf(paste(plot_dir,"vaccine_mds.pdf", sep =""))
#starts writing a PDF to file
plotMDS(lcpm,labels=group,col=col.group)
title(main= "Vaccination status") #Some clustering around TD already :)
dev.off()
```

### 2) Differential gene expression analysis

Once our data is pre-processed and normalised, we can compare counts or gene expression between participants and different groups.

If we just wanted to look at normalised counts/gene expression between two participants we could make direct comparisons, with no further modelling required

However if we want to make larger comparisons between groups of interest, i.e time points, or between vaccine groups, just comparing the mean expression of these two groups would be disingenuous, as it would not take into account other factors which influence the overall gene expression of that group.

For example comparing gene expression between Vi-TCV and Vi-PS particiapnts at D7, Vi-PS participants might have an older age, or more participants sequenced in a different batch that could affect the mean. By accounting for these factors/covariates we can more accurately estimate the mean gene expression for that group. These estimations are made using linear regression models.

The next step is to calculate the fold change in the average modeled gene expression between groups, e.g Vi-PS/TCV at D7, or between different time points.

The parameters we include in the model are specified within the *design matrix*, and the contrasts, or comparisons we would like to perform are specified within a *contrast matrix.*\
As both design and contrast matrices relate to sample expression/count data/norm factors stored in DGE matrices, they need to all be the same dimensions.

*Overall workflow:*
- design –> voom (first time) –> duplicateCorrelation –> voom (second time) –> lmFit –> contrasts.fit –> eBayes –> TopTable –> Volcano 

*Important Functions:*
- `lmFit` computes coefficients, residual variances and standard errors. For your linear model, the leading coefficients correspond to average log-expression values for different conditions
- `voom` Remove heteroskedasity in the data, - equalises variance. Necessary for RNA-seq data as it normalises the resiudals so they are no longer dependent on count size.
- `duplicateCorrelation` calculates the correlation between samples within your data, this correlation can then be included in the linear model as a blocking factor
- `contrasts.fit` converts the coefficients and standard errors to reflect the contrasts rather than the original design matrix, but does not compute t-statistics or p-values. As in the Limma manual: “The coefficients, unscaled standard deviations and correlation matrix are re-calculated in terms of the contrasts”
- `eBayes` computes t-statistics and p-values from the coefficients and standard errors. Therefore running eBayes before contrast.fit will give non-sensical results in terms of obtained p-values.


#### Design Matrix

Generally, data preparation for DEG analysis utilises all the samples in your study, even the ones that you might not care about using or comparing initially, and keeps them in a matrix format (this allows R to easily subset conditions, based on matching row or column indices).

Now at the start of your analysis, you might have an idea of some comparisons you would like to make, let's say the difference between vaccinated and non-vaccinated samples. (ignore time points for now)

We want to model the average difference (fold change) in gene expression between these two groups.
E.g `lm(exprs_data ~ vaccine_group)`

However, if one group had for example an older average participant age, or a technical batch differences that would skew the results, we want to include these factors as covariates in our model as such: `lm(exprs_data ~ vaccine_group + age + sex)`

When deciding on what parameters to include in the model we can test for significant effects by examining the MDS plots, variables that result in clustering/separation of data should therefore be included if we are measuring the overall gene expression.

The *design matrix* contains the model parameters we specify per each sample, and extracts this information from the corresponding metadata, i.e vaccine group, age, sequence_pool\
It is set up so that rows are associated with samples and columns are associated with the specified model parameters.

```{r add diagram, echo=FALSE}
# Define variable containing url
url <- "https://f1000researchdata.s3.amazonaws.com/manuscripts/30844/e0cd78d8-1ebb-48d6-a35c-007d3d42961c_figure2.gif"
#html code to place and size below inline text
```
<center><img src="`r url`"></center>

*Design matrix data prep*

1) Check metadata variable names/data types for design `clean_names()`
      - Design matrix can't have duplicate column names, weird symbols etc
      - Check numeric vars are recoded to factors if necessary
2) Check for NA values
      - Samples with Na values (in vars specified by design) are automatically removed from matrix
      - Causes trouble downstream as design/sample/contrast matrix will have uneven dims
      - Check for na's using `is.na` loop, poss recode to a dummy value if we need to keep them (they can be filtered out by the contrast selection later, so it's more of a code issue at this point)
3) Check for linear dependencies/rank
      - If some model parameters are dependent on another then these will mess up the linear model
4) Remove null variables
      - Vars with all 0s or NAs add nothing to the model so can be removed

*Linear dependencies notes*  
- The rank of the matrix is the total number of independent columns/vectors in the matrix.
- So if our matrix rank is smaller than the number of columns, then there must be linear dependencies, i.e that vector can be made up by either a copy of or multiplying another one of the vectors.
- A vector of all zeros will also count as a dependent vector, therefore need to remove these (as well as it being redundant for the model anyways)

- VAST Notes: My bet is on time_point and study arm, as the control group wont have vac time points, therefore should nest these factors? Update - removed control group from orignal data and design, also time_point D14 when checking using interaction time*vaccine, only had Vi-PS samples. So if you were to include D14 as a time point in the model you would also just be measuring the effects of Vi-PS, therefore for now when looking at both vaccine groups, excluding D14 from analysis

```{r Design Matrix, results='hide'}
pData <- data$samples
#str(pData)
#Change sequence pool to factor
data$samples$sequence_pool <- as.factor(data$samples$sequence_pool)

#Check for Nas
test <- data$samples[sapply(data$samples, function(x) sum(is.na(x))),]
#samples have data for the design categories, however are missing levels of time factor which results in them being ommited from model.matrix - it was the vaccine rip

#Model design matrix
design <- model.matrix(~0+ time_point3 + study_arm + sex + sequence_pool, data = data$samples)
#Leave out diagnosis for now

# 1) Test for linear dependencies ####
ncol(design) 
qr(design)$rank # Unequal ncol-rank = linear dependencies present

# 2) Find linear dependent cols
rankifremoved <- sapply(1:ncol(design), function (x) qr(design[,-x])$rank)
#Column (design factor) if removed, that result in the highest rank are the linearly dependent ones (since removing those does not decrease rank, while removing a linearly independent column does).
which(rankifremoved == max(rankifremoved))

# 3) Remove Problem variables
#Remove null variables, i.e = all 0s or NAs (Control)
#Remove linear dependent vars (D14)
colSums(design) == 0
design <- design[,-c(8:9)] 
#Re-check rank/ncol
ncol(design) 
qr(design)$rank

#Tidy new design colnames
colnames(design)<-gsub("study_arm","",colnames(design))
colnames(design)<-gsub("time_point3","",colnames(design))
colnames(design) <- gsub("\\+", "plus", colnames(design))
```
*Intercept terms*
For a single explanatory variable a design matrix can be coded by `model.matrix(~variable)` to include an intercept term, or by model.matrix(~0+variable) to exclude the intercept term.\
If our variable is categorical, then design models with and without the intercept term are equivalent, but if variable is a numerical covariate, then the choice of model type matters

- If we have any numeric (non-catgorical) variables in our model, it is best to include a y intercept, as the model of gene expression may not start from zero
- If we just have categorical variables, e.g we are comparing gene expression between two treatment groups then we don't need to include the intercept and it can be excluded by `model.matrix(~0+ variable)`

### Limma Voom

Limma uses linear modelling on log-CPM values to model gene expression from RNAseq data, an assumption of the model is that the errors/residuals/variance are normally distributed.\
However, it has been established that for RNAseq data there is a non-linear relationship between the number of counts of a given gene, and the variance of those counts.\
Because the variance is unequal across a range of values, i.e the data is heteroskedastic, we have to normalise this unequal variance.\
The voom function normalises/adjusts variance so it is no longer dependent on count size, and we can model gene expression accurately in future steps.\

As the voom function is normalising the residuals around a fitted model, we need to input the design matrix as described in section 2, which specifies linear model variables, to perform voom accordingly


```{r Voom 1}
#Plots mean count size (x) against variance (y)
#Lower counts tend to have lower variance
#Therefore voom normalises - flattens this trend
#Variances are calculated by fitting a linear model to the data provided by the design matrix

v <- voom(data,design,plot=TRUE)
```
Typically Voom plot shows higher variance for lower counts. If filtering was not performed properly,a drop in variance levels can be observed at the low end of the expression scale due to very small counts. Experiments with high biological variation tend to result in flatter trends, lower biological variation tend to have sharper trends.

When modelling gene expression between conditions using design/contrast matricies, we can now use our corrected data in the Voom object (S4), and visually check that we have removed the variance trend with log expression. 

### Blocking factors

As we have repeated measurements on the same participant/sample, we should account for the fact that gene expression across time points will correlate with the participant it was measured in. 

Account for this using the cor.fit as a 'blocking factor' in the linear model
```{r corfit}
#Estimate the correlation between measurements made on the same subject:
corfit <- duplicateCorrelation(v, design=design, block=data$samples$lab_id)
corfit$consensus #0.32

#Voom 2 ####
# Apply voom again on original data (with the block and correlation parameters this time)
pdf(file = paste(plot_dir,"voom_2.pdf", sep = ""))
v2 <- voom(data,design,
           block = data$samples$lab_id, correlation = corfit$consensus,
           plot=TRUE)
dev.off()

  #y, design, block = targets$Block, correlation = corfit$consensus)

#Lmfit 1###
fit <- lmFit(v2, design, block = data$samples$lab_id, correlation = corfit$consensus)
```

```{r Save/load limma voom data}
#save.image(file = "~/RNA/Daniel/diff_expr_results/VAST_RNAseq.RData")
#load(file = "~/RNA/Daniel/diff_expr_results/VAST_RNAseq.RData")
```

### Contrast Matrix

Our contrast matrix will go through all of our samples and indicate whether a sample is to be used compared, and which group it belongs to.\
The matrix is set up as so that rows are associated with model parameters and columns represent the contrast of interest

```{r All contrast matricies}
#Use contrasts_2_lm function to model designated comparisons between control/baseline
#Also outputs toptable results

#Comparing D1, D7 and 28 days post-vac with baseline
results <- contrast_2_lm(group = c("V7", "V1", "D0"), control = c("V0"),efit=fit, des_mat = design)

cm <- results$contrasts
fit2 <- results$fit2
toptables <- results$top_results

plotSA(fit2) #check variance post-voom
```

### Data visualisation

#### Plot Pipeline

- input toptable results file
- speficy directories + plot names
- can modify highlighted genes/sig levels


```{r Volcano Plots}

#V1 vols ####

# UPDATE file dirs and data
#system("mkdir ~/GWAS_22/new_gwas/Plots/DEG/volcanos/V1")
plot_dir <- c("~/GWAS_22/new_gwas/Plots/DEG/volcanos/V1/")
plot_title <- c("24h Post-vaccination")

deg <- toptables$V1_vs_V0 


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#Modify gene names
deg$gene_name <- str_replace(deg$gene_name, "TNFSF13B", "BAFF")
deg$gene_name <- str_replace(deg$gene_name, "TNFSF13", "APRIL")
genes_neut <- c("APRIL", "BAFF","IL1B")
genes_fc <- c("FCGR3A","FCGR3C","FCAR","FCGR1B","FCGR2A", "FCGR2B", "FCGR2C", "FCGR1A")


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

top <- plot_vol(deg, lab = 'top', title = plot_title)
neut <-plot_vol(deg, lab = 'sig',genes = genes_neut, title = plot_title)
fc <- plot_vol(deg, lab = 'sig',genes = genes_fc, title = plot_title)

#Save plots ####
pdf(file = paste(plot_dir, "sig_neut.pdf", sep = ""))
neut
dev.off()
pdf(file = paste(plot_dir, "sig_fc.pdf", sep = ""))
fc
dev.off()
pdf(file = paste(plot_dir, "topgenes.pdf", sep = ""))
fc
dev.off()
fc
```

*Todo* check labels in plot_vol function code


### Results:

*D28 notes*

- Most genes return to baseline/not many sig genes
- To be expected 1-month post-vac
- Relabel vol with sig genes

*D7 notes*

- No sig change in FcRs
- Quite a skewed volcano

*D1 notes*

- FcRs 2a 1a sig upreg
- Neut genes sig up reg